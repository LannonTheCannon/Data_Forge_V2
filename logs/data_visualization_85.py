# Disclaimer: This function was generated by AI. Please review before using.
# Agent Name: data_visualization_agent
# Time Created: 2025-04-17 00:11:18

def data_visualization(data_raw):
    import pandas as pd
    import numpy as np
    import json
    import plotly.graph_objects as go
    import plotly.io as pio





    # data_raw has index as sub-category names and columns including 'count', 'min', '25%', '50%', '75%', 'max'
    # We want a boxplot with x = count, y = distribution of profit metrics (min, 25%, 50%, 75%, max)
    # Since the y is multiple columns and x is a single column, we interpret "x" as positions for each sub-category (count)
    # and show boxplots representing the distribution for that sub-category using the given stats.
    # Plotly boxplot needs raw data points or can be constructed from quartiles using a custom box trace.
    # Here, since we only have summary statistics, we will create box traces using the boxpoints=False and use quartile info.

    # To create boxplots from summary stats, Plotly allows setting quartile points with boxpoints=False and specifying quartile values.
    # But Plotly doesn't accept quartiles directly for boxplot trace, so we can emulate boxplots using go.Box with custom whiskers.

    # Another approach is to create one boxplot per sub-category with the five-number summary.
    # We can create one box trace per sub-category using go.Box with the 'q1', 'median', 'q3', 'lowerfence', 'upperfence' parameters.
    # However, Plotly's box trace doesn't accept these directly, so we use the box trace with the 'boxmean' and 'boxpoints' disabled and supply the raw data.

    # Since raw data is not available, we can simulate the boxplot by creating a box with the given quantiles.
    # Plotly does not support boxplots from summary stats directly, but we can use the box customdata approach or use go.Box with sample data constructed from the quantiles.

    # We'll generate a synthetic dataset for each sub-category from the given quantiles to mimic the distribution for visualization.

    # Prepare a DataFrame to hold synthetic data points for each sub-category
    synthetic_data = []
    for idx, row in data_raw.iterrows():
        # For each sub-category, create data points corresponding to min, 25%, 50%, 75%, max
        # To make a boxplot, we can replicate these values with some multiplicity for visualization
        points = []
        points.extend([row['min']] * 2)
        points.extend([row['25%']] * 3)
        points.extend([row['50%']] * 4)
        points.extend([row['75%']] * 3)
        points.extend([row['max']] * 2)
        for val in points:
            synthetic_data.append({'SubCategory': idx, 'count': row['count'], 'Profit': val})

    df_synthetic = pd.DataFrame(synthetic_data)

    # We will plot boxplots with x = count (as string for categorical axis), y = Profit
    # Since counts are numerical but represent sub-categories, we convert count to string for x-axis
    df_synthetic['count_str'] = df_synthetic['count'].astype(str) + ' (' + df_synthetic['SubCategory'] + ')'

    fig = go.Figure()

    # Get unique categories ordered by count to keep consistent order
    categories = df_synthetic[['count', 'count_str']].drop_duplicates().sort_values('count')

    for _, row in categories.iterrows():
        cat_data = df_synthetic[df_synthetic['count_str'] == row['count_str']]['Profit']
        fig.add_trace(go.Box(
            y=cat_data,
            name=row['count_str'],
            boxpoints=False,
            marker_color='blue',
            line=dict(width=2),
            showlegend=False
        ))

    fig.update_layout(
        title="Distribution of Profit across Sub-Category",
        xaxis_title="Sub-Category (represented by count)",
        yaxis_title="Profit Distribution Metrics",
        xaxis=dict(tickangle=45),
        template="plotly_white",
        margin=dict(t=60, b=150)
    )

    fig_json = pio.to_json(fig)
    fig_dict = json.loads(fig_json)

    return fig_dict