# Disclaimer: This function was generated by AI. Please review before using.
# Agent Name: data_visualization_agent
# Time Created: 2025-04-28 16:02:24

def data_visualization(data_raw):
    import pandas as pd
    import numpy as np
    import json
    import plotly.graph_objects as go
    import plotly.io as pio
    from plotly.subplots import make_subplots






    # Ensure categorical ordering for Month and Category
    month_order = [2, 3, 4]
    categories_order = data_raw['Category'].unique().tolist()
    payment_methods = data_raw['Payment Method'].unique().tolist()

    # Calculate average Price by Category, Month, and Payment Method
    avg_price = (
        data_raw.groupby(['Payment Method', 'Category', 'Month'], as_index=False)['Price']
        .mean()
    )

    # Create a consistent color scale range across all subplots
    price_min = avg_price['Price'].min()
    price_max = avg_price['Price'].max()

    # Prepare subplots: one heatmap per Payment Method, arranged horizontally
    n_methods = len(payment_methods)
    fig = make_subplots(
        rows=1,
        cols=n_methods,
        shared_yaxes=True,
        subplot_titles=payment_methods,
        horizontal_spacing=0.05,
        x_title="Month",
        y_title="Category",
    )

    # For each Payment Method create a heatmap
    for i, pm in enumerate(payment_methods, start=1):
        # Filter data for payment method
        df_pm = avg_price[avg_price['Payment Method'] == pm]

        # Pivot table: index=Category (y), columns=Month (x), values=Price (color)
        heatmap_data = df_pm.pivot(index='Category', columns='Month', values='Price')

        # Reindex to ensure all categories and months appear in order
        heatmap_data = heatmap_data.reindex(index=categories_order, columns=month_order)

        # Convert to list of lists and replace NaN with None (Plotly understands None as missing)
        z = heatmap_data.where(pd.notnull(heatmap_data), None).values.tolist()

        # Create heatmap trace
        heatmap = go.Heatmap(
            z=z,
            x=[str(m) for m in month_order],
            y=categories_order,
            coloraxis="coloraxis",
            hovertemplate='Category: %{y}<br>Month: %{x}<br>Avg Price: %{z:.2f}<extra></extra>',
        )

        fig.add_trace(heatmap, row=1, col=i)

        # Set xaxis and yaxis properties for each subplot
        xaxis_name = f'xaxis{i}' if i > 1 else 'xaxis'
        yaxis_name = f'yaxis{i}' if i > 1 else 'yaxis'
        fig.layout[xaxis_name].update(
            type='category',
            categoryorder='array',
            categoryarray=[str(m) for m in month_order],
            tickmode='array',
            tickvals=[str(m) for m in month_order],
            ticktext=[str(m) for m in month_order],
            title_text="Month",
            showgrid=False,
            side='bottom',
            ticks='outside',
            tickangle=0,
        )
        fig.layout[yaxis_name].update(
            type='category',
            categoryorder='array',
            categoryarray=categories_order,
            tickmode='array',
            tickvals=categories_order,
            ticktext=categories_order,
            title_text="Category",
            showgrid=False,
            autorange='reversed',
            ticks='outside',
        )

    # Update layout with a consistent coloraxis (color scale)
    fig.update_layout(
        title_text="Seasonal Trends in Average Price by Category and Month Across Payment Methods",
        coloraxis=dict(
            colorscale='Viridis',
            cmin=price_min,
            cmax=price_max,
            colorbar=dict(
                title="Avg Price",
                ticks="outside",
                tickformat=".0f",
                lenmode="fraction",
                len=0.75,
                y=0.5,
                yanchor="middle"
            )
        ),
        height=500,
        width=300 * n_methods,
        margin=dict(t=80, b=60, l=120, r=40),
        showlegend=False,
    )

    # Return figure as dict
    fig_json = pio.to_json(fig)
    fig_dict = json.loads(fig_json)

    return fig_dict